{"version":3,"file":"1-prepare-for-eval.js","names":["readFileSync","dirname","extname","createCustomDebug","buildOptions","getFileIdx","loadBabelOptions","withLinariaMetadata","ModuleQueue","cachedParseSync","loadLinariaOptions","isModuleResolver","i","key","runPreevalStage","babel","filename","code","options","perFileBabelConfig","pluginOptions","parseConfig","babelOptions","fullParserOptions","file","transformPlugins","require","resolve","moduleResolverPlugin","plugins","find","unshift","transformConfig","envName","sourceMaps","sourceFileName","inputSourceMap","root","ast","babelrc","configFile","result","transformFromAstSync","program","Error","getMatchedRule","rules","length","rule","test","RegExp","action","prepareCode","originalCode","only","log","endsWith","preevalStageResult","metadata","evaluator","paths","default","name","processQueueItem","item","cache","undefined","onlyAsStr","join","extension","extensions","includes","preparedCode","imports","isEqual","a","b","sort","every","index","prepareForEvalSync","entrypoint","queue","isEmpty","nextItem","resolveStack","dequeue","cached","codeCache","get","mergedOnly","Array","from","Set","processed","importedFile","importsOnly","resolved","resolveCacheKey","resolveCached","resolveCache","importsOnlySet","cachedOnly","split","forEach","token","add","set","fileContent","enqueue","err","prepareForEval","evalCache","delete"],"sources":["../../src/transform-stages/1-prepare-for-eval.ts"],"sourcesContent":["/* eslint-disable no-restricted-syntax,no-continue,no-await-in-loop */\nimport { readFileSync } from 'fs';\nimport { dirname, extname } from 'path';\n\nimport type { BabelFileResult, TransformOptions } from '@babel/core';\n\nimport { createCustomDebug } from '@linaria/logger';\nimport type { EvalRule, Evaluator } from '@linaria/utils';\nimport { buildOptions, getFileIdx, loadBabelOptions } from '@linaria/utils';\n\nimport type { Core } from '../babel';\nimport type { TransformCacheCollection } from '../cache';\nimport type Module from '../module';\nimport type { ITransformFileResult, Options } from '../types';\nimport withLinariaMetadata from '../utils/withLinariaMetadata';\n\nimport type { IEntrypoint } from './helpers/ModuleQueue';\nimport { ModuleQueue } from './helpers/ModuleQueue';\nimport cachedParseSync from './helpers/cachedParseSync';\nimport loadLinariaOptions from './helpers/loadLinariaOptions';\n\nconst isModuleResolver = (i: unknown): i is { options: unknown } =>\n  typeof i === 'object' &&\n  i !== null &&\n  (i as { key?: string }).key === 'module-resolver';\n\nfunction runPreevalStage(\n  babel: Core,\n  filename: string,\n  code: string,\n  options: Pick<Options, 'root' | 'pluginOptions' | 'inputSourceMap'>,\n  perFileBabelConfig?: TransformOptions\n): BabelFileResult {\n  const pluginOptions = loadLinariaOptions(options.pluginOptions);\n  const parseConfig = buildOptions(\n    pluginOptions?.babelOptions,\n    perFileBabelConfig\n  );\n\n  const fullParserOptions = loadBabelOptions(babel, filename, parseConfig);\n  const file = cachedParseSync(babel, code, fullParserOptions);\n\n  const transformPlugins: babel.PluginItem[] = [\n    [require.resolve('../plugins/preeval'), pluginOptions],\n  ];\n\n  const moduleResolverPlugin =\n    fullParserOptions.plugins?.find(isModuleResolver);\n  if (moduleResolverPlugin) {\n    transformPlugins.unshift(moduleResolverPlugin);\n  }\n\n  const transformConfig = buildOptions({\n    envName: 'linaria',\n    plugins: transformPlugins,\n    sourceMaps: true,\n    sourceFileName: filename,\n    inputSourceMap: options.inputSourceMap,\n    root: options.root,\n    ast: true,\n    babelrc: false,\n    configFile: false,\n  });\n\n  const result = babel.transformFromAstSync(file, code, {\n    ...transformConfig,\n    filename,\n  });\n\n  if (!result || !result.ast?.program) {\n    throw new Error('Babel transform failed');\n  }\n\n  return result;\n}\n\nfunction getMatchedRule(\n  rules: EvalRule[],\n  filename: string,\n  code: string\n): EvalRule {\n  for (let i = rules.length - 1; i >= 0; i--) {\n    const rule = rules[i];\n    if (!rule.test) {\n      return rule;\n    }\n\n    if (typeof rule.test === 'function' && rule.test(filename, code)) {\n      return rule;\n    }\n\n    if (rule.test instanceof RegExp && rule.test.test(filename)) {\n      return rule;\n    }\n  }\n\n  return { action: 'ignore' };\n}\n\nexport function prepareCode(\n  babel: Core,\n  filename: string,\n  originalCode: string,\n  only: string[],\n  options: Pick<Options, 'root' | 'pluginOptions' | 'inputSourceMap'>\n): [\n  code: string,\n  imports: Module['imports'],\n  metadata?: babel.BabelFileMetadata\n] {\n  const log = createCustomDebug('transform', getFileIdx(filename));\n\n  const pluginOptions = loadLinariaOptions(options.pluginOptions);\n\n  const { action, babelOptions } = getMatchedRule(\n    pluginOptions.rules,\n    filename,\n    originalCode\n  );\n\n  if (action === 'ignore' || filename.endsWith('.json')) {\n    log('stage-1:ignore', '');\n\n    return [originalCode, null];\n  }\n\n  const preevalStageResult = runPreevalStage(\n    babel,\n    filename,\n    originalCode,\n    options,\n    babelOptions\n  );\n\n  if (\n    only.length === 1 &&\n    only[0] === '__linariaPreval' &&\n    !withLinariaMetadata(preevalStageResult.metadata)\n  ) {\n    log('stage-1:evaluator:end', 'no metadata');\n    return [preevalStageResult.code!, null, preevalStageResult.metadata];\n  }\n\n  log('stage-1:preeval', 'metadata %O', preevalStageResult.metadata);\n\n  // Action can be a function or a module name\n  const evaluator: Evaluator =\n    typeof action === 'function'\n      ? action\n      : require(require.resolve(action, {\n          paths: [dirname(filename)],\n        })).default;\n\n  log('stage-1:evaluator:start', 'using %s', evaluator.name);\n\n  const result = evaluator(\n    filename,\n    pluginOptions,\n    preevalStageResult.code!,\n    only,\n    babel\n  );\n\n  log('stage-1:evaluator:end', '');\n\n  return [...result, preevalStageResult.metadata];\n}\n\nfunction processQueueItem(\n  babel: Core,\n  item: {\n    name: string;\n    code: string;\n    only: string[];\n  } | null,\n  cache: TransformCacheCollection,\n  options: Pick<Options, 'root' | 'pluginOptions' | 'inputSourceMap'>\n):\n  | {\n      imports: Map<string, string[]> | null;\n      name: string;\n      result: ITransformFileResult;\n    }\n  | undefined {\n  if (!item) {\n    return undefined;\n  }\n\n  const pluginOptions = loadLinariaOptions(options.pluginOptions);\n  const { name, only, code } = item;\n  const onlyAsStr = only.join(', ');\n  const log = createCustomDebug('transform', getFileIdx(name));\n  const extension = extname(name);\n\n  if (!pluginOptions.extensions.includes(extension)) {\n    log(\n      'init',\n      `${name} is ignored. If you want it to be processed, you should add '${extension}' to the \"extensions\" option.`\n    );\n    return undefined;\n  }\n\n  log('init', `${name} (${onlyAsStr})\\n${code}`);\n\n  log('stage-1', `>> (${onlyAsStr})`);\n\n  const [preparedCode, imports, metadata] = prepareCode(\n    babel,\n    name,\n    code,\n    only,\n    options\n  );\n\n  if (code === preparedCode) {\n    log('stage-1', `<< (${onlyAsStr})\\n === no changes ===`);\n  } else {\n    log('stage-1', `<< (${onlyAsStr})\\n${preparedCode}`);\n  }\n\n  if (preparedCode === '') return undefined;\n\n  return {\n    imports,\n    name,\n    result: {\n      metadata,\n      code: preparedCode,\n    },\n  };\n}\n\nconst isEqual = ([...a]: string[], [...b]: string[]) => {\n  if (a.includes('*')) return true;\n  if (a.length !== b.length) return false;\n  a.sort();\n  b.sort();\n  return a.every((item, index) => item === b[index]);\n};\n\nexport function prepareForEvalSync(\n  babel: Core,\n  cache: TransformCacheCollection,\n  resolve: (what: string, importer: string, stack: string[]) => string,\n  entrypoint: IEntrypoint,\n  options: Pick<Options, 'root' | 'pluginOptions' | 'inputSourceMap'>\n): ITransformFileResult | undefined {\n  const queue = new ModuleQueue(entrypoint);\n\n  while (!queue.isEmpty()) {\n    const [nextItem, resolveStack] = queue.dequeue() ?? [];\n    if (!nextItem || !resolveStack) {\n      continue;\n    }\n\n    const { name, only, code } = nextItem;\n    const log = createCustomDebug('transform', getFileIdx(name));\n\n    const cached = cache.codeCache.get(name);\n    // If we already have a result for this file, we should get a result for merged `only`\n    const mergedOnly = cached?.only\n      ? Array.from(new Set([...cached.only, ...only]))\n      : only;\n\n    if (cached && isEqual(cached.only, mergedOnly)) {\n      log('stage-1', '%s is already processed', name);\n      continue;\n    }\n\n    const processed = processQueueItem(\n      babel,\n      {\n        name,\n        code,\n        only: mergedOnly,\n      },\n      cache,\n      options\n    );\n\n    if (!processed) continue;\n\n    const { imports, result } = processed;\n\n    for (const [importedFile, importsOnly] of imports ?? []) {\n      try {\n        const resolved = resolve(importedFile, name, resolveStack);\n        log(\n          'stage-1:sync-resolve',\n          `✅ ${importedFile} -> ${resolved} (only: %o)`,\n          importsOnly\n        );\n\n        const resolveCacheKey = `${name} -> ${importedFile}`;\n        const resolveCached = cache.resolveCache.get(resolveCacheKey);\n        const importsOnlySet = new Set(importsOnly);\n        if (resolveCached) {\n          const [, cachedOnly] = resolveCached.split('\\0');\n          cachedOnly?.split(',').forEach((token) => {\n            importsOnlySet.add(token);\n          });\n        }\n\n        cache.resolveCache.set(\n          resolveCacheKey,\n          `${resolved}\\0${[...importsOnlySet].join(',')}`\n        );\n\n        const fileContent = readFileSync(resolved, 'utf8');\n        queue.enqueue([\n          {\n            name: resolved,\n            only: importsOnly,\n            code: fileContent,\n          },\n          [name, ...resolveStack],\n        ]);\n      } catch (err) {\n        log(\n          'stage-1:sync-resolve',\n          `❌ cannot resolve ${importedFile}: %O`,\n          err\n        );\n      }\n    }\n\n    cache.codeCache.set(name, {\n      imports,\n      only: mergedOnly,\n      result,\n    });\n  }\n\n  return cache.codeCache.get(entrypoint.name)?.result;\n}\n\n/**\n * Parses the specified file and recursively all its dependencies,\n * finds tags, applies eval-time replacements, removes dead code.\n */\nexport default async function prepareForEval(\n  babel: Core,\n  cache: TransformCacheCollection,\n  resolve: (\n    what: string,\n    importer: string,\n    stack: string[]\n  ) => Promise<string | null>,\n  entrypoint: IEntrypoint,\n  options: Pick<Options, 'root' | 'pluginOptions' | 'inputSourceMap'>\n): Promise<ITransformFileResult | undefined> {\n  /*\n   * This method can be run simultaneously for multiple files.\n   * A shared cache is accessible for all runs, but each run has its own queue\n   * to maintain the correct processing order. The cache stores the outcome\n   * of tree-shaking, and if the result is already stored in the cache\n   * but the \"only\" option has changed, the file will be re-processed using\n   * the combined \"only\" option.\n   */\n  const log = createCustomDebug('transform', getFileIdx(entrypoint.name));\n\n  const queue = new ModuleQueue(entrypoint);\n\n  while (!queue.isEmpty()) {\n    const [nextItem, resolveStack] = queue.dequeue() ?? [];\n    if (!nextItem || !resolveStack) {\n      continue;\n    }\n\n    const { name, only, code } = nextItem;\n\n    const cached = cache.codeCache.get(name);\n    // If we already have a result for this file, we should get a result for merged `only`\n    const mergedOnly = cached?.only\n      ? Array.from(new Set([...cached.only, ...only]))\n      : only;\n\n    let imports: Map<string, string[]> | null = null;\n    let result: ITransformFileResult | undefined;\n\n    if (cached) {\n      if (isEqual(cached.only, mergedOnly)) {\n        log('stage-1', '%s is already processed', name);\n        if (!resolveStack.includes(nextItem.name)) {\n          imports = cached.imports;\n        }\n\n        result = cached.result;\n      } else {\n        log(\n          'stage-1',\n          '%s is already processed, but with different `only` %o (the cached one %o)',\n          name,\n          only,\n          cached?.only\n        );\n\n        // If we already have a result for this file, we should invalidate it\n        cache.evalCache.delete(name);\n      }\n    }\n\n    if (!result) {\n      const processed = processQueueItem(\n        babel,\n        {\n          name,\n          code,\n          only: mergedOnly,\n        },\n        cache,\n        options\n      );\n\n      if (!processed) {\n        log('stage-1', '%s is skipped', name);\n        continue;\n      }\n\n      imports = processed.imports;\n      result = processed.result;\n    }\n\n    if (imports) {\n      for (const [importedFile, importsOnly] of imports) {\n        let resolved: string | null = null;\n        try {\n          resolved = await resolve(importedFile, name, resolveStack);\n        } catch (err) {\n          log(\n            'stage-1:async-resolve',\n            `❌ cannot resolve %s in %s: %O`,\n            importedFile,\n            name,\n            err\n          );\n        }\n\n        if (resolved === null) {\n          log('stage-1:resolve', `✅ %s in %s is ignored`, importedFile, name);\n          continue;\n        }\n\n        log(\n          'stage-1:async-resolve',\n          `✅ %s (%o) in %s -> %s`,\n          importedFile,\n          importsOnly,\n          name,\n          resolved\n        );\n\n        const resolveCacheKey = `${name} -> ${importedFile}`;\n        const resolveCached = cache.resolveCache.get(resolveCacheKey);\n        const importsOnlySet = new Set(importsOnly);\n        if (resolveCached) {\n          const [, cachedOnly] = resolveCached.split('\\0');\n          cachedOnly?.split(',').forEach((token) => {\n            importsOnlySet.add(token);\n          });\n        }\n\n        cache.resolveCache.set(\n          resolveCacheKey,\n          `${resolved}\\0${[...importsOnlySet].join(',')}`\n        );\n\n        const fileContent = readFileSync(resolved, 'utf8');\n        queue.enqueue([\n          {\n            name: resolved,\n            only: importsOnly,\n            code: fileContent,\n          },\n          [name, ...resolveStack],\n        ]);\n      }\n    } else {\n      log('stage-1', '%s has no imports', name);\n    }\n\n    cache.codeCache.set(name, {\n      imports,\n      only: mergedOnly,\n      result,\n    });\n  }\n\n  log('stage-1', 'queue is empty, %s is ready', entrypoint.name);\n\n  return cache.codeCache.get(entrypoint.name)?.result;\n}\n"],"mappings":"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"}