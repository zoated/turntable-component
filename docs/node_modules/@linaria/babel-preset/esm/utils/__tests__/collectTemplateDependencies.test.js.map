{"version":3,"file":"collectTemplateDependencies.test.js","names":["babel","parseAsync","generate","dedent","stripAnsi","extractExpression","File","go","code","parsed","filename","__filename","file","ast","path","traverse","TemplateLiteral","expressions","get","forEach","exp","isExpression","describe","it","expect","toMatchSnapshot","assertions","e","message"],"sources":["../../../src/utils/__tests__/collectTemplateDependencies.test.ts"],"sourcesContent":["import * as babel from '@babel/core';\nimport { parseAsync } from '@babel/core';\nimport generate from '@babel/generator';\nimport dedent from 'dedent';\nimport stripAnsi from 'strip-ansi';\n\nimport type { MissedBabelCoreTypes } from '../../types';\nimport { extractExpression } from '../collectTemplateDependencies';\n\nconst { File } = babel as typeof babel & MissedBabelCoreTypes;\n\nasync function go(code: string): Promise<string> {\n  const parsed = (await parseAsync(code, {\n    filename: __filename,\n  }))!;\n\n  const file = new File({ filename: __filename }, { code, ast: parsed });\n\n  file.path.traverse({\n    TemplateLiteral(path) {\n      const expressions = path.get('expressions');\n      expressions.forEach((exp) => {\n        if (exp.isExpression()) {\n          extractExpression(exp, true, false);\n        }\n      });\n    },\n  });\n\n  return generate(parsed).code;\n}\n\ndescribe('collectTemplateDependencies', () => {\n  it('hoist expressions', async () => {\n    const code = dedent`\n      import x from \"module\";\n\n      function fn() {\n        const value = 21;\n        const variable = \"test\";\n        const result = \"result\";\n        const template = tag\\`${'${value * 2}'}${'${variable}'}${'${(() => result)}'}${'${value * x}'}\\`;\n      }\n    `;\n\n    expect(await go(code)).toMatchSnapshot();\n  });\n\n  it('should hoist expressions after imports', async () => {\n    const code = dedent`\n      import { styled } from '@linaria/react';\n      import slugify from '../__fixtures__/slugify';\n\n      export const Title = styled.h1\\`\n        &:before {\n          content: \"${\"${slugify('test')}\"}\"\n        }\n      \\`;\n    `;\n\n    expect(await go(code)).toMatchSnapshot();\n  });\n\n  it('non-hoistable expression', async () => {\n    expect.assertions(1);\n\n    const code = dedent`\n      function fn(arg) {\n        {\n          const base = \"base\";\n          const variable = base + arg;\n          const template = tag\\`${'${variable}'}\\`;\n        }\n      }\n    `;\n\n    try {\n      await go(code);\n    } catch (e) {\n      expect(stripAnsi((e as { message: string }).message)).toMatchSnapshot();\n    }\n  });\n\n  it('hoist chain of statements', async () => {\n    const code = dedent`\n      import str from \"module\";\n\n      function fn() {\n        {\n          const arg = str;\n          const variable = arg + \"2\";\n          const template = tag\\`${'${variable}'}\\`;\n        }\n      }\n    `;\n\n    expect(await go(code)).toMatchSnapshot();\n  });\n\n  it('hoistExpression with destructuring', async () => {\n    const code = dedent`\n      function fn() {\n        const result = \"result\";\n        const { variable } = { variable: result };\n        const template = tag\\`${'${variable}'}\\`;\n      }\n    `;\n\n    expect(await go(code)).toMatchSnapshot();\n  });\n\n  it('hoistExpression with object', async () => {\n    const code = dedent`\n      const obj = {\n        variable: \"test\",\n      }\n\n      function fn() {\n        const template = tag\\`${'${obj.variable}'}\\`;\n      }\n    `;\n\n    expect(await go(code)).toMatchSnapshot();\n  });\n});\n"],"mappings":"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"}