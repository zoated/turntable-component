{"version":3,"file":"collectTemplateDependencies.js","names":["createId","name","loc","type","staticEval","ex","evaluate","undefined","result","confident","hasMeta","value","expressionDeclarationTpl","statement","preserveComments","unsupported","reason","buildCodeFrameError","isIdentifier","getUidInRootScope","path","node","rootScope","scope","getProgramParent","hasBinding","generateUid","hoistVariableDeclarator","parent","referencedIdentifiers","findIdentifiers","forEach","identifier","hoistIdentifier","bindingIdentifiers","newName","rename","statementInRoot","findParent","p","parentPath","isProgram","declaration","kind","declarations","cloneNode","inserted","insertBefore","referenceAll","registerDeclaration","idPath","isReferenced","binding","getBinding","includes","bindingPath","isVariableDeclarator","getOrAddLinariaPreval","object","getData","prevalExport","expression","operator","left","property","computed","right","properties","programPath","pushContainer","get","setData","addIdentifierToLinariaPreval","newProperty","key","shorthand","reference","extractExpression","addToExport","isLiteral","ValueType","CONST","isFunction","isFunctionExpression","isArrowFunctionExpression","expUid","evaluated","id","evaluatedId","mutate","replaceWith","valueToLiteral","FUNCTION","LAZY","expId","callee","arguments","collectTemplateDependencies","quasi","quasis","expressions","debug","length","expressionValues","map","bind","source","getSource","isExpression","extracted"],"sources":["../../src/utils/collectTemplateDependencies.ts"],"sourcesContent":["/* eslint @typescript-eslint/no-use-before-define: [\"error\", { \"functions\": false }] */\n\n/**\n * This file is a visitor that checks TaggedTemplateExpressions and look for Linaria css or styled templates.\n * For each template it makes a list of dependencies, try to evaluate expressions, and if it is not possible, mark them as lazy dependencies.\n */\n\nimport { statement } from '@babel/template';\nimport type { NodePath, Scope } from '@babel/traverse';\nimport type {\n  Expression,\n  ExpressionStatement,\n  Identifier,\n  JSXIdentifier,\n  ObjectExpression,\n  ObjectProperty,\n  Program,\n  SourceLocation,\n  Statement,\n  TaggedTemplateExpression,\n  TemplateElement,\n  TSType,\n  VariableDeclaration,\n  VariableDeclarator,\n} from '@babel/types';\nimport { cloneNode } from '@babel/types';\n\nimport { debug } from '@linaria/logger';\nimport type { ConstValue } from '@linaria/tags';\nimport { hasMeta } from '@linaria/tags';\nimport {\n  findIdentifiers,\n  mutate,\n  reference,\n  referenceAll,\n} from '@linaria/utils';\n\nimport type { ExpressionValue } from '../types';\nimport { ValueType } from '../types';\n\nimport getSource from './getSource';\nimport valueToLiteral from './vlueToLiteral';\n\nconst createId = (name: string, loc?: SourceLocation | null): Identifier => ({\n  type: 'Identifier',\n  name,\n  loc,\n});\n\nfunction staticEval(\n  ex: NodePath<Expression>,\n  evaluate = false\n): [unknown] | undefined {\n  if (!evaluate) return undefined;\n\n  const result = ex.evaluate();\n  if (result.confident && !hasMeta(result.value)) {\n    return [result.value];\n  }\n\n  return undefined;\n}\n\nconst expressionDeclarationTpl = statement(\n  'const %%expId%% = /*#__PURE__*/ () => %%expression%%',\n  {\n    preserveComments: true,\n  }\n);\n\nconst unsupported = (ex: NodePath, reason?: string): Error =>\n  ex.buildCodeFrameError(\n    `This ${\n      ex.isIdentifier() ? 'identifier' : 'expression'\n    } cannot be used in the template${reason ? `, because it ${reason}` : ''}.`\n  );\n\nfunction getUidInRootScope(path: NodePath<Identifier | JSXIdentifier>): string {\n  const { name } = path.node;\n  const rootScope = path.scope.getProgramParent();\n  if (rootScope.hasBinding(name)) {\n    return rootScope.generateUid(name);\n  }\n\n  return name;\n}\n\nfunction hoistVariableDeclarator(ex: NodePath<VariableDeclarator>) {\n  if (!ex.scope.parent) {\n    // It is already in the root scope\n    return;\n  }\n\n  const referencedIdentifiers = findIdentifiers([ex], 'referenced');\n  referencedIdentifiers.forEach((identifier) => {\n    if (identifier.isIdentifier()) {\n      hoistIdentifier(identifier);\n    }\n  });\n\n  const bindingIdentifiers = findIdentifiers([ex], 'binding');\n\n  bindingIdentifiers.forEach((path) => {\n    const newName = getUidInRootScope(path);\n    if (newName !== path.node.name) {\n      path.scope.rename(path.node.name, newName);\n    }\n  });\n\n  const rootScope = ex.scope.getProgramParent();\n\n  const statementInRoot = ex.findParent(\n    (p) => p.parentPath?.isProgram() === true\n  ) as NodePath<Statement>;\n\n  const declaration: VariableDeclaration = {\n    type: 'VariableDeclaration',\n    kind: 'let',\n    declarations: [cloneNode(ex.node)],\n  };\n\n  const [inserted] = statementInRoot.insertBefore(declaration);\n  referenceAll(inserted);\n  rootScope.registerDeclaration(inserted);\n}\n\nfunction hoistIdentifier(idPath: NodePath<Identifier>): void {\n  if (!idPath.isReferenced()) {\n    throw unsupported(idPath);\n  }\n\n  const binding = idPath.scope.getBinding(idPath.node.name);\n  if (!binding) {\n    // It's something strange\n    throw unsupported(idPath, 'is undefined');\n  }\n\n  if (binding.kind === 'module') {\n    // Modules are global by default\n    return;\n  }\n\n  if (!['var', 'let', 'const', 'hoisted'].includes(binding.kind)) {\n    // This is not a variable, we can't hoist it\n    throw unsupported(binding.path, 'is a function parameter');\n  }\n\n  const { scope, path: bindingPath } = binding;\n  // parent here can be null or undefined in different versions of babel\n  if (!scope.parent) {\n    // The variable is already in the root scope\n    return;\n  }\n\n  if (bindingPath.isVariableDeclarator()) {\n    hoistVariableDeclarator(bindingPath);\n\n    return;\n  }\n\n  throw unsupported(idPath);\n}\n\nfunction getOrAddLinariaPreval(scope: Scope): NodePath<ObjectExpression> {\n  const rootScope = scope.getProgramParent();\n  let object = rootScope.getData('__linariaPreval');\n  if (object) {\n    return object;\n  }\n\n  const prevalExport: ExpressionStatement = {\n    type: 'ExpressionStatement',\n    expression: {\n      type: 'AssignmentExpression',\n      operator: '=',\n      left: {\n        type: 'MemberExpression',\n        object: createId('exports'),\n        property: createId('__linariaPreval'),\n        computed: false,\n      },\n      right: {\n        type: 'ObjectExpression',\n        properties: [],\n      },\n    },\n  };\n\n  const programPath = rootScope.path as NodePath<Program>;\n  const [inserted] = programPath.pushContainer('body', [prevalExport]);\n  object = inserted.get('expression.right') as NodePath<ObjectExpression>;\n  rootScope.setData('__linariaPreval', object);\n  return object;\n}\n\nfunction addIdentifierToLinariaPreval(scope: Scope, name: string) {\n  const rootScope = scope.getProgramParent();\n  const object = getOrAddLinariaPreval(rootScope);\n  const newProperty: ObjectProperty = {\n    type: 'ObjectProperty',\n    key: createId(name),\n    value: createId(name),\n    computed: false,\n    shorthand: false,\n  };\n\n  const [inserted] = object.pushContainer('properties', [newProperty]);\n  reference(inserted.get('value') as NodePath<Identifier>);\n}\n\n/**\n * Only an expression that can be evaluated in the root scope can be\n * used in a Linaria template. This function tries to hoist the expression.\n * @param ex The expression to hoist.\n * @param evaluate If true, we try to statically evaluate the expression.\n * @param addToExport If true, we add the expression to the __linariaPreval.\n */\nexport function extractExpression(\n  ex: NodePath<Expression>,\n  evaluate = false,\n  addToExport = true\n): Omit<ExpressionValue, 'buildCodeFrameError' | 'source'> {\n  if (\n    ex.isLiteral() &&\n    ('value' in ex.node || ex.node.type === 'NullLiteral')\n  ) {\n    return {\n      ex: ex.node,\n      kind: ValueType.CONST,\n      value: ex.node.type === 'NullLiteral' ? null : ex.node.value,\n    } as Omit<ConstValue, 'buildCodeFrameError' | 'source'>;\n  }\n\n  const { loc } = ex.node;\n\n  const rootScope = ex.scope.getProgramParent();\n  const statementInRoot = ex.findParent(\n    (p) => p.parentPath?.isProgram() === true\n  ) as NodePath<Statement>;\n\n  const isFunction =\n    ex.isFunctionExpression() || ex.isArrowFunctionExpression();\n\n  // Generate next _expN name\n  const expUid = rootScope.generateUid('exp');\n\n  const evaluated = staticEval(ex, evaluate);\n\n  if (!evaluated) {\n    // If expression is not statically evaluable,\n    // we need to hoist all its referenced identifiers\n\n    // Collect all referenced identifiers\n    findIdentifiers([ex], 'referenced').forEach((id) => {\n      if (!id.isIdentifier()) return;\n\n      // Try to evaluate and inline them…\n      const evaluatedId = staticEval(id, evaluate);\n      if (evaluatedId) {\n        mutate(id, (p) => {\n          p.replaceWith(valueToLiteral(evaluatedId[0], ex));\n        });\n      } else {\n        // … or hoist them to the root scope\n        hoistIdentifier(id);\n      }\n    });\n  }\n\n  const kind = isFunction ? ValueType.FUNCTION : ValueType.LAZY;\n\n  // Declare _expN const with the lazy expression\n  const declaration = expressionDeclarationTpl({\n    expId: createId(expUid),\n    expression: evaluated\n      ? valueToLiteral(evaluated[0], ex)\n      : cloneNode(ex.node),\n  }) as VariableDeclaration;\n\n  // Insert the declaration as close as possible to the original expression\n  const [inserted] = statementInRoot.insertBefore(declaration);\n  referenceAll(inserted);\n  rootScope.registerDeclaration(inserted);\n\n  // Replace the expression with the _expN() call\n  mutate(ex, (p) => {\n    p.replaceWith({\n      type: 'CallExpression',\n      callee: createId(expUid),\n      arguments: [],\n    });\n  });\n\n  if (addToExport) {\n    addIdentifierToLinariaPreval(rootScope, expUid);\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  ex.node.loc = loc;\n\n  return {\n    kind,\n    ex: createId(expUid, loc),\n  };\n}\n\n/**\n * Collects, hoists, and makes lazy all expressions in the given template\n * If evaluate is true, it will try to evaluate the expressions\n */\nexport default function collectTemplateDependencies(\n  path: NodePath<TaggedTemplateExpression>,\n  evaluate = false\n): [quasis: TemplateElement[], expressionValues: ExpressionValue[]] {\n  const quasi = path.get('quasi');\n  const quasis = quasi.get('quasis');\n  const expressions = quasi.get('expressions');\n\n  debug('template-parse:identify-expressions', expressions.length);\n\n  const expressionValues: ExpressionValue[] = expressions.map(\n    (ex: NodePath<Expression | TSType>): ExpressionValue => {\n      const buildCodeFrameError = ex.buildCodeFrameError.bind(ex);\n      const source = getSource(ex);\n\n      if (!ex.isExpression()) {\n        throw buildCodeFrameError(\n          `The expression '${source}' is not supported.`\n        );\n      }\n\n      const extracted = extractExpression(ex, evaluate);\n\n      return {\n        ...extracted,\n        source,\n        buildCodeFrameError,\n      } as ExpressionValue;\n    }\n  );\n\n  return [quasis.map((p) => p.node), expressionValues];\n}\n"],"mappings":";;;;;;;AAOA;AAkBA;AAEA;AAEA;AACA;AAQA;AAEA;AACA;AAA6C;AAzC7C;;AAEA;AACA;AACA;AACA;;AAsCA,MAAMA,QAAQ,GAAG,CAACC,IAAY,EAAEC,GAA2B,MAAkB;EAC3EC,IAAI,EAAE,YAAY;EAClBF,IAAI;EACJC;AACF,CAAC,CAAC;AAEF,SAASE,UAAU,CACjBC,EAAwB,EACxBC,QAAQ,GAAG,KAAK,EACO;EACvB,IAAI,CAACA,QAAQ,EAAE,OAAOC,SAAS;EAE/B,MAAMC,MAAM,GAAGH,EAAE,CAACC,QAAQ,EAAE;EAC5B,IAAIE,MAAM,CAACC,SAAS,IAAI,CAAC,IAAAC,aAAO,EAACF,MAAM,CAACG,KAAK,CAAC,EAAE;IAC9C,OAAO,CAACH,MAAM,CAACG,KAAK,CAAC;EACvB;EAEA,OAAOJ,SAAS;AAClB;AAEA,MAAMK,wBAAwB,GAAG,IAAAC,mBAAS,EACxC,sDAAsD,EACtD;EACEC,gBAAgB,EAAE;AACpB,CAAC,CACF;AAED,MAAMC,WAAW,GAAG,CAACV,EAAY,EAAEW,MAAe,KAChDX,EAAE,CAACY,mBAAmB,CACnB,QACCZ,EAAE,CAACa,YAAY,EAAE,GAAG,YAAY,GAAG,YACpC,kCAAiCF,MAAM,GAAI,gBAAeA,MAAO,EAAC,GAAG,EAAG,GAAE,CAC5E;AAEH,SAASG,iBAAiB,CAACC,IAA0C,EAAU;EAC7E,MAAM;IAAEnB;EAAK,CAAC,GAAGmB,IAAI,CAACC,IAAI;EAC1B,MAAMC,SAAS,GAAGF,IAAI,CAACG,KAAK,CAACC,gBAAgB,EAAE;EAC/C,IAAIF,SAAS,CAACG,UAAU,CAACxB,IAAI,CAAC,EAAE;IAC9B,OAAOqB,SAAS,CAACI,WAAW,CAACzB,IAAI,CAAC;EACpC;EAEA,OAAOA,IAAI;AACb;AAEA,SAAS0B,uBAAuB,CAACtB,EAAgC,EAAE;EACjE,IAAI,CAACA,EAAE,CAACkB,KAAK,CAACK,MAAM,EAAE;IACpB;IACA;EACF;EAEA,MAAMC,qBAAqB,GAAG,IAAAC,sBAAe,EAAC,CAACzB,EAAE,CAAC,EAAE,YAAY,CAAC;EACjEwB,qBAAqB,CAACE,OAAO,CAAEC,UAAU,IAAK;IAC5C,IAAIA,UAAU,CAACd,YAAY,EAAE,EAAE;MAC7Be,eAAe,CAACD,UAAU,CAAC;IAC7B;EACF,CAAC,CAAC;EAEF,MAAME,kBAAkB,GAAG,IAAAJ,sBAAe,EAAC,CAACzB,EAAE,CAAC,EAAE,SAAS,CAAC;EAE3D6B,kBAAkB,CAACH,OAAO,CAAEX,IAAI,IAAK;IACnC,MAAMe,OAAO,GAAGhB,iBAAiB,CAACC,IAAI,CAAC;IACvC,IAAIe,OAAO,KAAKf,IAAI,CAACC,IAAI,CAACpB,IAAI,EAAE;MAC9BmB,IAAI,CAACG,KAAK,CAACa,MAAM,CAAChB,IAAI,CAACC,IAAI,CAACpB,IAAI,EAAEkC,OAAO,CAAC;IAC5C;EACF,CAAC,CAAC;EAEF,MAAMb,SAAS,GAAGjB,EAAE,CAACkB,KAAK,CAACC,gBAAgB,EAAE;EAE7C,MAAMa,eAAe,GAAGhC,EAAE,CAACiC,UAAU,CAClCC,CAAC;IAAA;IAAA,OAAK,kBAAAA,CAAC,CAACC,UAAU,kDAAZ,cAAcC,SAAS,EAAE,MAAK,IAAI;EAAA,EACnB;EAExB,MAAMC,WAAgC,GAAG;IACvCvC,IAAI,EAAE,qBAAqB;IAC3BwC,IAAI,EAAE,KAAK;IACXC,YAAY,EAAE,CAAC,IAAAC,gBAAS,EAACxC,EAAE,CAACgB,IAAI,CAAC;EACnC,CAAC;EAED,MAAM,CAACyB,QAAQ,CAAC,GAAGT,eAAe,CAACU,YAAY,CAACL,WAAW,CAAC;EAC5D,IAAAM,mBAAY,EAACF,QAAQ,CAAC;EACtBxB,SAAS,CAAC2B,mBAAmB,CAACH,QAAQ,CAAC;AACzC;AAEA,SAASb,eAAe,CAACiB,MAA4B,EAAQ;EAC3D,IAAI,CAACA,MAAM,CAACC,YAAY,EAAE,EAAE;IAC1B,MAAMpC,WAAW,CAACmC,MAAM,CAAC;EAC3B;EAEA,MAAME,OAAO,GAAGF,MAAM,CAAC3B,KAAK,CAAC8B,UAAU,CAACH,MAAM,CAAC7B,IAAI,CAACpB,IAAI,CAAC;EACzD,IAAI,CAACmD,OAAO,EAAE;IACZ;IACA,MAAMrC,WAAW,CAACmC,MAAM,EAAE,cAAc,CAAC;EAC3C;EAEA,IAAIE,OAAO,CAACT,IAAI,KAAK,QAAQ,EAAE;IAC7B;IACA;EACF;EAEA,IAAI,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,SAAS,CAAC,CAACW,QAAQ,CAACF,OAAO,CAACT,IAAI,CAAC,EAAE;IAC9D;IACA,MAAM5B,WAAW,CAACqC,OAAO,CAAChC,IAAI,EAAE,yBAAyB,CAAC;EAC5D;EAEA,MAAM;IAAEG,KAAK;IAAEH,IAAI,EAAEmC;EAAY,CAAC,GAAGH,OAAO;EAC5C;EACA,IAAI,CAAC7B,KAAK,CAACK,MAAM,EAAE;IACjB;IACA;EACF;EAEA,IAAI2B,WAAW,CAACC,oBAAoB,EAAE,EAAE;IACtC7B,uBAAuB,CAAC4B,WAAW,CAAC;IAEpC;EACF;EAEA,MAAMxC,WAAW,CAACmC,MAAM,CAAC;AAC3B;AAEA,SAASO,qBAAqB,CAAClC,KAAY,EAA8B;EACvE,MAAMD,SAAS,GAAGC,KAAK,CAACC,gBAAgB,EAAE;EAC1C,IAAIkC,MAAM,GAAGpC,SAAS,CAACqC,OAAO,CAAC,iBAAiB,CAAC;EACjD,IAAID,MAAM,EAAE;IACV,OAAOA,MAAM;EACf;EAEA,MAAME,YAAiC,GAAG;IACxCzD,IAAI,EAAE,qBAAqB;IAC3B0D,UAAU,EAAE;MACV1D,IAAI,EAAE,sBAAsB;MAC5B2D,QAAQ,EAAE,GAAG;MACbC,IAAI,EAAE;QACJ5D,IAAI,EAAE,kBAAkB;QACxBuD,MAAM,EAAE1D,QAAQ,CAAC,SAAS,CAAC;QAC3BgE,QAAQ,EAAEhE,QAAQ,CAAC,iBAAiB,CAAC;QACrCiE,QAAQ,EAAE;MACZ,CAAC;MACDC,KAAK,EAAE;QACL/D,IAAI,EAAE,kBAAkB;QACxBgE,UAAU,EAAE;MACd;IACF;EACF,CAAC;EAED,MAAMC,WAAW,GAAG9C,SAAS,CAACF,IAAyB;EACvD,MAAM,CAAC0B,QAAQ,CAAC,GAAGsB,WAAW,CAACC,aAAa,CAAC,MAAM,EAAE,CAACT,YAAY,CAAC,CAAC;EACpEF,MAAM,GAAGZ,QAAQ,CAACwB,GAAG,CAAC,kBAAkB,CAA+B;EACvEhD,SAAS,CAACiD,OAAO,CAAC,iBAAiB,EAAEb,MAAM,CAAC;EAC5C,OAAOA,MAAM;AACf;AAEA,SAASc,4BAA4B,CAACjD,KAAY,EAAEtB,IAAY,EAAE;EAChE,MAAMqB,SAAS,GAAGC,KAAK,CAACC,gBAAgB,EAAE;EAC1C,MAAMkC,MAAM,GAAGD,qBAAqB,CAACnC,SAAS,CAAC;EAC/C,MAAMmD,WAA2B,GAAG;IAClCtE,IAAI,EAAE,gBAAgB;IACtBuE,GAAG,EAAE1E,QAAQ,CAACC,IAAI,CAAC;IACnBU,KAAK,EAAEX,QAAQ,CAACC,IAAI,CAAC;IACrBgE,QAAQ,EAAE,KAAK;IACfU,SAAS,EAAE;EACb,CAAC;EAED,MAAM,CAAC7B,QAAQ,CAAC,GAAGY,MAAM,CAACW,aAAa,CAAC,YAAY,EAAE,CAACI,WAAW,CAAC,CAAC;EACpE,IAAAG,gBAAS,EAAC9B,QAAQ,CAACwB,GAAG,CAAC,OAAO,CAAC,CAAyB;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASO,iBAAiB,CAC/BxE,EAAwB,EACxBC,QAAQ,GAAG,KAAK,EAChBwE,WAAW,GAAG,IAAI,EACuC;EACzD,IACEzE,EAAE,CAAC0E,SAAS,EAAE,KACb,OAAO,IAAI1E,EAAE,CAACgB,IAAI,IAAIhB,EAAE,CAACgB,IAAI,CAAClB,IAAI,KAAK,aAAa,CAAC,EACtD;IACA,OAAO;MACLE,EAAE,EAAEA,EAAE,CAACgB,IAAI;MACXsB,IAAI,EAAEqC,iBAAS,CAACC,KAAK;MACrBtE,KAAK,EAAEN,EAAE,CAACgB,IAAI,CAAClB,IAAI,KAAK,aAAa,GAAG,IAAI,GAAGE,EAAE,CAACgB,IAAI,CAACV;IACzD,CAAC;EACH;EAEA,MAAM;IAAET;EAAI,CAAC,GAAGG,EAAE,CAACgB,IAAI;EAEvB,MAAMC,SAAS,GAAGjB,EAAE,CAACkB,KAAK,CAACC,gBAAgB,EAAE;EAC7C,MAAMa,eAAe,GAAGhC,EAAE,CAACiC,UAAU,CAClCC,CAAC;IAAA;IAAA,OAAK,mBAAAA,CAAC,CAACC,UAAU,mDAAZ,eAAcC,SAAS,EAAE,MAAK,IAAI;EAAA,EACnB;EAExB,MAAMyC,UAAU,GACd7E,EAAE,CAAC8E,oBAAoB,EAAE,IAAI9E,EAAE,CAAC+E,yBAAyB,EAAE;;EAE7D;EACA,MAAMC,MAAM,GAAG/D,SAAS,CAACI,WAAW,CAAC,KAAK,CAAC;EAE3C,MAAM4D,SAAS,GAAGlF,UAAU,CAACC,EAAE,EAAEC,QAAQ,CAAC;EAE1C,IAAI,CAACgF,SAAS,EAAE;IACd;IACA;;IAEA;IACA,IAAAxD,sBAAe,EAAC,CAACzB,EAAE,CAAC,EAAE,YAAY,CAAC,CAAC0B,OAAO,CAAEwD,EAAE,IAAK;MAClD,IAAI,CAACA,EAAE,CAACrE,YAAY,EAAE,EAAE;;MAExB;MACA,MAAMsE,WAAW,GAAGpF,UAAU,CAACmF,EAAE,EAAEjF,QAAQ,CAAC;MAC5C,IAAIkF,WAAW,EAAE;QACf,IAAAC,aAAM,EAACF,EAAE,EAAGhD,CAAC,IAAK;UAChBA,CAAC,CAACmD,WAAW,CAAC,IAAAC,sBAAc,EAACH,WAAW,CAAC,CAAC,CAAC,EAAEnF,EAAE,CAAC,CAAC;QACnD,CAAC,CAAC;MACJ,CAAC,MAAM;QACL;QACA4B,eAAe,CAACsD,EAAE,CAAC;MACrB;IACF,CAAC,CAAC;EACJ;EAEA,MAAM5C,IAAI,GAAGuC,UAAU,GAAGF,iBAAS,CAACY,QAAQ,GAAGZ,iBAAS,CAACa,IAAI;;EAE7D;EACA,MAAMnD,WAAW,GAAG9B,wBAAwB,CAAC;IAC3CkF,KAAK,EAAE9F,QAAQ,CAACqF,MAAM,CAAC;IACvBxB,UAAU,EAAEyB,SAAS,GACjB,IAAAK,sBAAc,EAACL,SAAS,CAAC,CAAC,CAAC,EAAEjF,EAAE,CAAC,GAChC,IAAAwC,gBAAS,EAACxC,EAAE,CAACgB,IAAI;EACvB,CAAC,CAAwB;;EAEzB;EACA,MAAM,CAACyB,QAAQ,CAAC,GAAGT,eAAe,CAACU,YAAY,CAACL,WAAW,CAAC;EAC5D,IAAAM,mBAAY,EAACF,QAAQ,CAAC;EACtBxB,SAAS,CAAC2B,mBAAmB,CAACH,QAAQ,CAAC;;EAEvC;EACA,IAAA2C,aAAM,EAACpF,EAAE,EAAGkC,CAAC,IAAK;IAChBA,CAAC,CAACmD,WAAW,CAAC;MACZvF,IAAI,EAAE,gBAAgB;MACtB4F,MAAM,EAAE/F,QAAQ,CAACqF,MAAM,CAAC;MACxBW,SAAS,EAAE;IACb,CAAC,CAAC;EACJ,CAAC,CAAC;EAEF,IAAIlB,WAAW,EAAE;IACfN,4BAA4B,CAAClD,SAAS,EAAE+D,MAAM,CAAC;EACjD;;EAEA;EACAhF,EAAE,CAACgB,IAAI,CAACnB,GAAG,GAAGA,GAAG;EAEjB,OAAO;IACLyC,IAAI;IACJtC,EAAE,EAAEL,QAAQ,CAACqF,MAAM,EAAEnF,GAAG;EAC1B,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACe,SAAS+F,2BAA2B,CACjD7E,IAAwC,EACxCd,QAAQ,GAAG,KAAK,EACkD;EAClE,MAAM4F,KAAK,GAAG9E,IAAI,CAACkD,GAAG,CAAC,OAAO,CAAC;EAC/B,MAAM6B,MAAM,GAAGD,KAAK,CAAC5B,GAAG,CAAC,QAAQ,CAAC;EAClC,MAAM8B,WAAW,GAAGF,KAAK,CAAC5B,GAAG,CAAC,aAAa,CAAC;EAE5C,IAAA+B,aAAK,EAAC,qCAAqC,EAAED,WAAW,CAACE,MAAM,CAAC;EAEhE,MAAMC,gBAAmC,GAAGH,WAAW,CAACI,GAAG,CACxDnG,EAAiC,IAAsB;IACtD,MAAMY,mBAAmB,GAAGZ,EAAE,CAACY,mBAAmB,CAACwF,IAAI,CAACpG,EAAE,CAAC;IAC3D,MAAMqG,MAAM,GAAG,IAAAC,kBAAS,EAACtG,EAAE,CAAC;IAE5B,IAAI,CAACA,EAAE,CAACuG,YAAY,EAAE,EAAE;MACtB,MAAM3F,mBAAmB,CACtB,mBAAkByF,MAAO,qBAAoB,CAC/C;IACH;IAEA,MAAMG,SAAS,GAAGhC,iBAAiB,CAACxE,EAAE,EAAEC,QAAQ,CAAC;IAEjD,OAAO;MACL,GAAGuG,SAAS;MACZH,MAAM;MACNzF;IACF,CAAC;EACH,CAAC,CACF;EAED,OAAO,CAACkF,MAAM,CAACK,GAAG,CAAEjE,CAAC,IAAKA,CAAC,CAAClB,IAAI,CAAC,EAAEkF,gBAAgB,CAAC;AACtD"}