{"version":3,"file":"collectTemplateDependencies.test.js","names":["File","babel","go","code","parsed","parseAsync","filename","__filename","file","ast","path","traverse","TemplateLiteral","expressions","get","forEach","exp","isExpression","extractExpression","generate","describe","it","dedent","expect","toMatchSnapshot","assertions","e","stripAnsi","message"],"sources":["../../../src/utils/__tests__/collectTemplateDependencies.test.ts"],"sourcesContent":["import * as babel from '@babel/core';\nimport { parseAsync } from '@babel/core';\nimport generate from '@babel/generator';\nimport dedent from 'dedent';\nimport stripAnsi from 'strip-ansi';\n\nimport type { MissedBabelCoreTypes } from '../../types';\nimport { extractExpression } from '../collectTemplateDependencies';\n\nconst { File } = babel as typeof babel & MissedBabelCoreTypes;\n\nasync function go(code: string): Promise<string> {\n  const parsed = (await parseAsync(code, {\n    filename: __filename,\n  }))!;\n\n  const file = new File({ filename: __filename }, { code, ast: parsed });\n\n  file.path.traverse({\n    TemplateLiteral(path) {\n      const expressions = path.get('expressions');\n      expressions.forEach((exp) => {\n        if (exp.isExpression()) {\n          extractExpression(exp, true, false);\n        }\n      });\n    },\n  });\n\n  return generate(parsed).code;\n}\n\ndescribe('collectTemplateDependencies', () => {\n  it('hoist expressions', async () => {\n    const code = dedent`\n      import x from \"module\";\n\n      function fn() {\n        const value = 21;\n        const variable = \"test\";\n        const result = \"result\";\n        const template = tag\\`${'${value * 2}'}${'${variable}'}${'${(() => result)}'}${'${value * x}'}\\`;\n      }\n    `;\n\n    expect(await go(code)).toMatchSnapshot();\n  });\n\n  it('should hoist expressions after imports', async () => {\n    const code = dedent`\n      import { styled } from '@linaria/react';\n      import slugify from '../__fixtures__/slugify';\n\n      export const Title = styled.h1\\`\n        &:before {\n          content: \"${\"${slugify('test')}\"}\"\n        }\n      \\`;\n    `;\n\n    expect(await go(code)).toMatchSnapshot();\n  });\n\n  it('non-hoistable expression', async () => {\n    expect.assertions(1);\n\n    const code = dedent`\n      function fn(arg) {\n        {\n          const base = \"base\";\n          const variable = base + arg;\n          const template = tag\\`${'${variable}'}\\`;\n        }\n      }\n    `;\n\n    try {\n      await go(code);\n    } catch (e) {\n      expect(stripAnsi((e as { message: string }).message)).toMatchSnapshot();\n    }\n  });\n\n  it('hoist chain of statements', async () => {\n    const code = dedent`\n      import str from \"module\";\n\n      function fn() {\n        {\n          const arg = str;\n          const variable = arg + \"2\";\n          const template = tag\\`${'${variable}'}\\`;\n        }\n      }\n    `;\n\n    expect(await go(code)).toMatchSnapshot();\n  });\n\n  it('hoistExpression with destructuring', async () => {\n    const code = dedent`\n      function fn() {\n        const result = \"result\";\n        const { variable } = { variable: result };\n        const template = tag\\`${'${variable}'}\\`;\n      }\n    `;\n\n    expect(await go(code)).toMatchSnapshot();\n  });\n\n  it('hoistExpression with object', async () => {\n    const code = dedent`\n      const obj = {\n        variable: \"test\",\n      }\n\n      function fn() {\n        const template = tag\\`${'${obj.variable}'}\\`;\n      }\n    `;\n\n    expect(await go(code)).toMatchSnapshot();\n  });\n});\n"],"mappings":"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"}