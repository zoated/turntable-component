{"version":3,"file":"1-prepare-for-eval.js","names":["isModuleResolver","i","key","runPreevalStage","babel","filename","code","options","perFileBabelConfig","pluginOptions","loadLinariaOptions","parseConfig","buildOptions","babelOptions","fullParserOptions","loadBabelOptions","file","cachedParseSync","transformPlugins","require","resolve","moduleResolverPlugin","plugins","find","unshift","transformConfig","envName","sourceMaps","sourceFileName","inputSourceMap","root","ast","babelrc","configFile","result","transformFromAstSync","program","Error","getMatchedRule","rules","length","rule","test","RegExp","action","prepareCode","originalCode","only","log","createCustomDebug","getFileIdx","endsWith","preevalStageResult","withLinariaMetadata","metadata","evaluator","paths","dirname","default","name","processQueueItem","item","cache","undefined","onlyAsStr","join","extension","extname","extensions","includes","preparedCode","imports","isEqual","a","b","sort","every","index","prepareForEvalSync","entrypoint","queue","ModuleQueue","isEmpty","nextItem","resolveStack","dequeue","cached","codeCache","get","mergedOnly","Array","from","Set","processed","importedFile","importsOnly","resolved","resolveCacheKey","resolveCached","resolveCache","importsOnlySet","cachedOnly","split","forEach","token","add","set","fileContent","readFileSync","enqueue","err","prepareForEval","evalCache","delete"],"sources":["../../src/transform-stages/1-prepare-for-eval.ts"],"sourcesContent":["/* eslint-disable no-restricted-syntax,no-continue,no-await-in-loop */\nimport { readFileSync } from 'fs';\nimport { dirname, extname } from 'path';\n\nimport type { BabelFileResult, TransformOptions } from '@babel/core';\n\nimport { createCustomDebug } from '@linaria/logger';\nimport type { EvalRule, Evaluator } from '@linaria/utils';\nimport { buildOptions, getFileIdx, loadBabelOptions } from '@linaria/utils';\n\nimport type { Core } from '../babel';\nimport type { TransformCacheCollection } from '../cache';\nimport type Module from '../module';\nimport type { ITransformFileResult, Options } from '../types';\nimport withLinariaMetadata from '../utils/withLinariaMetadata';\n\nimport type { IEntrypoint } from './helpers/ModuleQueue';\nimport { ModuleQueue } from './helpers/ModuleQueue';\nimport cachedParseSync from './helpers/cachedParseSync';\nimport loadLinariaOptions from './helpers/loadLinariaOptions';\n\nconst isModuleResolver = (i: unknown): i is { options: unknown } =>\n  typeof i === 'object' &&\n  i !== null &&\n  (i as { key?: string }).key === 'module-resolver';\n\nfunction runPreevalStage(\n  babel: Core,\n  filename: string,\n  code: string,\n  options: Pick<Options, 'root' | 'pluginOptions' | 'inputSourceMap'>,\n  perFileBabelConfig?: TransformOptions\n): BabelFileResult {\n  const pluginOptions = loadLinariaOptions(options.pluginOptions);\n  const parseConfig = buildOptions(\n    pluginOptions?.babelOptions,\n    perFileBabelConfig\n  );\n\n  const fullParserOptions = loadBabelOptions(babel, filename, parseConfig);\n  const file = cachedParseSync(babel, code, fullParserOptions);\n\n  const transformPlugins: babel.PluginItem[] = [\n    [require.resolve('../plugins/preeval'), pluginOptions],\n  ];\n\n  const moduleResolverPlugin =\n    fullParserOptions.plugins?.find(isModuleResolver);\n  if (moduleResolverPlugin) {\n    transformPlugins.unshift(moduleResolverPlugin);\n  }\n\n  const transformConfig = buildOptions({\n    envName: 'linaria',\n    plugins: transformPlugins,\n    sourceMaps: true,\n    sourceFileName: filename,\n    inputSourceMap: options.inputSourceMap,\n    root: options.root,\n    ast: true,\n    babelrc: false,\n    configFile: false,\n  });\n\n  const result = babel.transformFromAstSync(file, code, {\n    ...transformConfig,\n    filename,\n  });\n\n  if (!result || !result.ast?.program) {\n    throw new Error('Babel transform failed');\n  }\n\n  return result;\n}\n\nfunction getMatchedRule(\n  rules: EvalRule[],\n  filename: string,\n  code: string\n): EvalRule {\n  for (let i = rules.length - 1; i >= 0; i--) {\n    const rule = rules[i];\n    if (!rule.test) {\n      return rule;\n    }\n\n    if (typeof rule.test === 'function' && rule.test(filename, code)) {\n      return rule;\n    }\n\n    if (rule.test instanceof RegExp && rule.test.test(filename)) {\n      return rule;\n    }\n  }\n\n  return { action: 'ignore' };\n}\n\nexport function prepareCode(\n  babel: Core,\n  filename: string,\n  originalCode: string,\n  only: string[],\n  options: Pick<Options, 'root' | 'pluginOptions' | 'inputSourceMap'>\n): [\n  code: string,\n  imports: Module['imports'],\n  metadata?: babel.BabelFileMetadata\n] {\n  const log = createCustomDebug('transform', getFileIdx(filename));\n\n  const pluginOptions = loadLinariaOptions(options.pluginOptions);\n\n  const { action, babelOptions } = getMatchedRule(\n    pluginOptions.rules,\n    filename,\n    originalCode\n  );\n\n  if (action === 'ignore' || filename.endsWith('.json')) {\n    log('stage-1:ignore', '');\n\n    return [originalCode, null];\n  }\n\n  const preevalStageResult = runPreevalStage(\n    babel,\n    filename,\n    originalCode,\n    options,\n    babelOptions\n  );\n\n  if (\n    only.length === 1 &&\n    only[0] === '__linariaPreval' &&\n    !withLinariaMetadata(preevalStageResult.metadata)\n  ) {\n    log('stage-1:evaluator:end', 'no metadata');\n    return [preevalStageResult.code!, null, preevalStageResult.metadata];\n  }\n\n  log('stage-1:preeval', 'metadata %O', preevalStageResult.metadata);\n\n  // Action can be a function or a module name\n  const evaluator: Evaluator =\n    typeof action === 'function'\n      ? action\n      : require(require.resolve(action, {\n          paths: [dirname(filename)],\n        })).default;\n\n  log('stage-1:evaluator:start', 'using %s', evaluator.name);\n\n  const result = evaluator(\n    filename,\n    pluginOptions,\n    preevalStageResult.code!,\n    only,\n    babel\n  );\n\n  log('stage-1:evaluator:end', '');\n\n  return [...result, preevalStageResult.metadata];\n}\n\nfunction processQueueItem(\n  babel: Core,\n  item: {\n    name: string;\n    code: string;\n    only: string[];\n  } | null,\n  cache: TransformCacheCollection,\n  options: Pick<Options, 'root' | 'pluginOptions' | 'inputSourceMap'>\n):\n  | {\n      imports: Map<string, string[]> | null;\n      name: string;\n      result: ITransformFileResult;\n    }\n  | undefined {\n  if (!item) {\n    return undefined;\n  }\n\n  const pluginOptions = loadLinariaOptions(options.pluginOptions);\n  const { name, only, code } = item;\n  const onlyAsStr = only.join(', ');\n  const log = createCustomDebug('transform', getFileIdx(name));\n  const extension = extname(name);\n\n  if (!pluginOptions.extensions.includes(extension)) {\n    log(\n      'init',\n      `${name} is ignored. If you want it to be processed, you should add '${extension}' to the \"extensions\" option.`\n    );\n    return undefined;\n  }\n\n  log('init', `${name} (${onlyAsStr})\\n${code}`);\n\n  log('stage-1', `>> (${onlyAsStr})`);\n\n  const [preparedCode, imports, metadata] = prepareCode(\n    babel,\n    name,\n    code,\n    only,\n    options\n  );\n\n  if (code === preparedCode) {\n    log('stage-1', `<< (${onlyAsStr})\\n === no changes ===`);\n  } else {\n    log('stage-1', `<< (${onlyAsStr})\\n${preparedCode}`);\n  }\n\n  if (preparedCode === '') return undefined;\n\n  return {\n    imports,\n    name,\n    result: {\n      metadata,\n      code: preparedCode,\n    },\n  };\n}\n\nconst isEqual = ([...a]: string[], [...b]: string[]) => {\n  if (a.includes('*')) return true;\n  if (a.length !== b.length) return false;\n  a.sort();\n  b.sort();\n  return a.every((item, index) => item === b[index]);\n};\n\nexport function prepareForEvalSync(\n  babel: Core,\n  cache: TransformCacheCollection,\n  resolve: (what: string, importer: string, stack: string[]) => string,\n  entrypoint: IEntrypoint,\n  options: Pick<Options, 'root' | 'pluginOptions' | 'inputSourceMap'>\n): ITransformFileResult | undefined {\n  const queue = new ModuleQueue(entrypoint);\n\n  while (!queue.isEmpty()) {\n    const [nextItem, resolveStack] = queue.dequeue() ?? [];\n    if (!nextItem || !resolveStack) {\n      continue;\n    }\n\n    const { name, only, code } = nextItem;\n    const log = createCustomDebug('transform', getFileIdx(name));\n\n    const cached = cache.codeCache.get(name);\n    // If we already have a result for this file, we should get a result for merged `only`\n    const mergedOnly = cached?.only\n      ? Array.from(new Set([...cached.only, ...only]))\n      : only;\n\n    if (cached && isEqual(cached.only, mergedOnly)) {\n      log('stage-1', '%s is already processed', name);\n      continue;\n    }\n\n    const processed = processQueueItem(\n      babel,\n      {\n        name,\n        code,\n        only: mergedOnly,\n      },\n      cache,\n      options\n    );\n\n    if (!processed) continue;\n\n    const { imports, result } = processed;\n\n    for (const [importedFile, importsOnly] of imports ?? []) {\n      try {\n        const resolved = resolve(importedFile, name, resolveStack);\n        log(\n          'stage-1:sync-resolve',\n          `✅ ${importedFile} -> ${resolved} (only: %o)`,\n          importsOnly\n        );\n\n        const resolveCacheKey = `${name} -> ${importedFile}`;\n        const resolveCached = cache.resolveCache.get(resolveCacheKey);\n        const importsOnlySet = new Set(importsOnly);\n        if (resolveCached) {\n          const [, cachedOnly] = resolveCached.split('\\0');\n          cachedOnly?.split(',').forEach((token) => {\n            importsOnlySet.add(token);\n          });\n        }\n\n        cache.resolveCache.set(\n          resolveCacheKey,\n          `${resolved}\\0${[...importsOnlySet].join(',')}`\n        );\n\n        const fileContent = readFileSync(resolved, 'utf8');\n        queue.enqueue([\n          {\n            name: resolved,\n            only: importsOnly,\n            code: fileContent,\n          },\n          [name, ...resolveStack],\n        ]);\n      } catch (err) {\n        log(\n          'stage-1:sync-resolve',\n          `❌ cannot resolve ${importedFile}: %O`,\n          err\n        );\n      }\n    }\n\n    cache.codeCache.set(name, {\n      imports,\n      only: mergedOnly,\n      result,\n    });\n  }\n\n  return cache.codeCache.get(entrypoint.name)?.result;\n}\n\n/**\n * Parses the specified file and recursively all its dependencies,\n * finds tags, applies eval-time replacements, removes dead code.\n */\nexport default async function prepareForEval(\n  babel: Core,\n  cache: TransformCacheCollection,\n  resolve: (\n    what: string,\n    importer: string,\n    stack: string[]\n  ) => Promise<string | null>,\n  entrypoint: IEntrypoint,\n  options: Pick<Options, 'root' | 'pluginOptions' | 'inputSourceMap'>\n): Promise<ITransformFileResult | undefined> {\n  /*\n   * This method can be run simultaneously for multiple files.\n   * A shared cache is accessible for all runs, but each run has its own queue\n   * to maintain the correct processing order. The cache stores the outcome\n   * of tree-shaking, and if the result is already stored in the cache\n   * but the \"only\" option has changed, the file will be re-processed using\n   * the combined \"only\" option.\n   */\n  const log = createCustomDebug('transform', getFileIdx(entrypoint.name));\n\n  const queue = new ModuleQueue(entrypoint);\n\n  while (!queue.isEmpty()) {\n    const [nextItem, resolveStack] = queue.dequeue() ?? [];\n    if (!nextItem || !resolveStack) {\n      continue;\n    }\n\n    const { name, only, code } = nextItem;\n\n    const cached = cache.codeCache.get(name);\n    // If we already have a result for this file, we should get a result for merged `only`\n    const mergedOnly = cached?.only\n      ? Array.from(new Set([...cached.only, ...only]))\n      : only;\n\n    let imports: Map<string, string[]> | null = null;\n    let result: ITransformFileResult | undefined;\n\n    if (cached) {\n      if (isEqual(cached.only, mergedOnly)) {\n        log('stage-1', '%s is already processed', name);\n        if (!resolveStack.includes(nextItem.name)) {\n          imports = cached.imports;\n        }\n\n        result = cached.result;\n      } else {\n        log(\n          'stage-1',\n          '%s is already processed, but with different `only` %o (the cached one %o)',\n          name,\n          only,\n          cached?.only\n        );\n\n        // If we already have a result for this file, we should invalidate it\n        cache.evalCache.delete(name);\n      }\n    }\n\n    if (!result) {\n      const processed = processQueueItem(\n        babel,\n        {\n          name,\n          code,\n          only: mergedOnly,\n        },\n        cache,\n        options\n      );\n\n      if (!processed) {\n        log('stage-1', '%s is skipped', name);\n        continue;\n      }\n\n      imports = processed.imports;\n      result = processed.result;\n    }\n\n    if (imports) {\n      for (const [importedFile, importsOnly] of imports) {\n        let resolved: string | null = null;\n        try {\n          resolved = await resolve(importedFile, name, resolveStack);\n        } catch (err) {\n          log(\n            'stage-1:async-resolve',\n            `❌ cannot resolve %s in %s: %O`,\n            importedFile,\n            name,\n            err\n          );\n        }\n\n        if (resolved === null) {\n          log('stage-1:resolve', `✅ %s in %s is ignored`, importedFile, name);\n          continue;\n        }\n\n        log(\n          'stage-1:async-resolve',\n          `✅ %s (%o) in %s -> %s`,\n          importedFile,\n          importsOnly,\n          name,\n          resolved\n        );\n\n        const resolveCacheKey = `${name} -> ${importedFile}`;\n        const resolveCached = cache.resolveCache.get(resolveCacheKey);\n        const importsOnlySet = new Set(importsOnly);\n        if (resolveCached) {\n          const [, cachedOnly] = resolveCached.split('\\0');\n          cachedOnly?.split(',').forEach((token) => {\n            importsOnlySet.add(token);\n          });\n        }\n\n        cache.resolveCache.set(\n          resolveCacheKey,\n          `${resolved}\\0${[...importsOnlySet].join(',')}`\n        );\n\n        const fileContent = readFileSync(resolved, 'utf8');\n        queue.enqueue([\n          {\n            name: resolved,\n            only: importsOnly,\n            code: fileContent,\n          },\n          [name, ...resolveStack],\n        ]);\n      }\n    } else {\n      log('stage-1', '%s has no imports', name);\n    }\n\n    cache.codeCache.set(name, {\n      imports,\n      only: mergedOnly,\n      result,\n    });\n  }\n\n  log('stage-1', 'queue is empty, %s is ready', entrypoint.name);\n\n  return cache.codeCache.get(entrypoint.name)?.result;\n}\n"],"mappings":"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"}